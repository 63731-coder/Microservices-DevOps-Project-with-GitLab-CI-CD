# DevOps Scenario
63731 - D112 - Opre Nicoleta

---

This DevOps project contains two microservices containerized with Docker, and a CI/CD pipeline configured with GitLab.

---
## Microservices

### 1. Java Spring Boot
- Port: `8080`
- Main file: `app.jar` (generated by Maven)
- Build: `mvn clean package`
- Environment variable: `FLASK_URL`

### 2. Python Flask
- Port: `5000`
- Main route: `/api/message` → `"Hello from Flask!"`
- Run: `python app.py`

---
## Containerization (Part 1)

Each service has its own **Dockerfile**:
- `Dockerfile` in `service-java/`
- `Dockerfile` in `service-python/`

### Local run:
```bash
docker compose up --build
```

---
## Continuous Integration – GitLab CI/CD (Part 2)

The `.gitlab-ci.yml` file contains the pipeline configuration.

### Defined jobs:
| Stage   | Job           | Description                                         |
|---------|---------------|-----------------------------------------------------|
| build   | `build-java`  | Compiles the Spring Boot service with Maven         |
| test    | `test-python` | Installs dependencies and runs Flask tests          |

> The pipeline runs automatically on each `git push`.

### Runner:
A **local Docker runner under WSL** is used to execute CI/CD jobs on a personal machine.

### Pipeline workflow

- **Trigger**: the pipeline automatically starts on each `git push` to the `main` branch.
- **Stages**:
  1. **build** → compiles the Java service (`build-java`)
  2. **test** → tests the Flask service (`test-python`)
- **Runner**: the pipeline uses a local Docker runner configured under WSL2 (Windows), manually registered via `gitlab-runner register`.
- **Docker images used**:
  - `maven:3.9-eclipse-temurin-17` for Java
  - `python:3.11-slim` for Flask
- **Goal**: ensure that each microservice can be built, tested, and is ready for deployment.

---
## Cloud Infrastructure – Azure with Terraform (Part 3)

### Goal

Deploy the required infrastructure on **Microsoft Azure** to host the two containerized microservices (Java Spring Boot and Python Flask) using **Terraform**.

---
### Azure resources created automatically

The Terraform configuration in the `terraform/` folder creates the following resources on Azure:

| Resource                          | Description                                                                  |
|-----------------------------------|------------------------------------------------------------------------------|
| `azurerm_resource_group`          | Resource group named `rg-microservices-app`                                  |
| `azurerm_container_registry`      | Private ACR `scenarioregistry63731` to store Docker images                   |
| `azurerm_user_assigned_identity`  | Managed identity for Azure Web Apps                                          |
| `azurerm_role_assignment`         | Assigns the `AcrPull` role to the identity to access the ACR                 |
| `azurerm_service_plan`            | Linux App Service Plan (B1) used by Web Apps                                 |
| `azurerm_linux_web_app` (x2)      | Two Web Apps to run the Docker containers of the services                    |

---
### Terraform file structure

| File                 | Role                                                                 |
|----------------------|----------------------------------------------------------------------|
| `main.tf`            | Defines the Azure resources                                          |
| `variables.tf`       | Customizable variables (names, ports, images, credentials)           |
| `providers.tf`       | Configures the Azure provider with a service principal               |
| `outputs.tf`         | Displays the final application URLs after deployment                 |

---
### Manual deployment with Terraform

#### Prerequisites
- Terraform ≥ 1.3
- Azure CLI (`az login`)
- Docker images **pushed** to ACR beforehand (`docker push`)

#### Steps

1. Initialize the Terraform project:
   ```bash
   cd terraform/
   terraform init
   ```

2. Import existing resources if needed:
   ```bash
   terraform import azurerm_resource_group.rg /subscriptions/xxx/resourceGroups/rg-microservices-app
   terraform import azurerm_container_registry.acr /subscriptions/xxx/resourceGroups/rg-microservices-app/providers/Microsoft.ContainerRegistry/registries/scenarioregistry63731
   terraform import azurerm_user_assigned_identity.identity /subscriptions/xxx/resourceGroups/rg-microservices-app/providers/Microsoft.ManagedIdentity/userAssignedIdentities/container-app-identity
   ```

3. Check the plan:
   ```bash
   terraform plan
   ```

4. Apply the deployment:
   ```bash
   terraform apply
   ```

The script will automatically deploy both services on Azure App Service, pulling their images from the ACR.

---
## Post-deployment verification

Access the Flask service:
```bash
https://mon-app-python-63731.azurewebsites.net/api/message
```

Should display:
```bash
Hello from Flask!
```

Access the Java service:
```bash
https://mon-app-java-63731.azurewebsites.net/proxy
```

Should display:
```bash
Hello from Flask!
```

Otherwise:
```bash
Flask service unreachable!
```

---
## Continuous Deployment – GitLab CI + Azure CLI (Part 4)

### Goal
Automate the deployment of Docker images to Azure App Service after build, using a GitLab runner configured with Docker-in-Docker and Azure CLI.

```
[runners.docker]
  image = "alpine:latest"
  privileged = true
  volumes = ["/cache"]...
```

`privileged = true` is required to run docker:dind (Docker-in-Docker).
